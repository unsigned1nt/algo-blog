{"/_includes/note-zadanie-preoi/":{"data":{"":"Note\nW trosce o zachowanie rozwiązań zadań w tajemnicy dla przyszłych edycji konkursu, nie będą podawane ich pełne nazwy. Zamiast nich będą stosowane oznaczenia z numerem dnia oraz pierwszą literą nazwy zadania. W ten sposób uczestnicy konkursu, z którego pochodzi zadanie odnajdą omówienie, gdy pozostałe osoby nie go rozpoznają."},"title":"note-zadanie-preoi"},"/blog/cf-1809f/":{"data":{"":"link do zadania: https://codeforces.com/contest/1809/problem/F","brute-force#Brute force":"Symulujemy proces podróży dla każdego iii. Możemy zastosować podobny trick jak w zadaniu CF 1238G Adilbek and the Watering System. W każdym momencie czasu trzymamy najlepsze kkk litrów paliwa, które mogliśmy kupić. Będziemy dodawać nowe i wyrzucać to najdroższe. Przy przejściu z miasta iii do kolejnego dokonujemy “zakupu” najtańszych aia_iai​ paliwa, które zapamiętaliśmy.\nWarto dodać, że w takim rozwiązaniu nie wykorzystujemy (możemy, nie musimy) założenia o bi∈{1,2}b_i \\in \\{1, 2\\}bi​∈{1,2}. Możemy użyć mapy (potrzebujemy min\\textit{min}min oraz max\\textit{max}max, można też użyć dwustronnej kolejki priorytetowej), wtedy dla każdego początku lll złożoność czasowa wyniesie O(n⋅log2(n))\\mathcal{O}(n \\cdot log_{2}(n))O(n⋅log2​(n)). Zatem mamy O(n2⋅log2(n))\\mathcal{O}(n^{2} \\cdot log_{2}(n))O(n2⋅log2​(n)).","brute-force-ale-sprytniejszy#Brute force, ale sprytniejszy":"Spróbujmy wykorzystać dodatkowe założenie, które ominęliśmy w poprzednim podejściu.\nPo pierwsze, zauważmy, że koszt podroˊz˙y≥∑i=1nai\\textit{koszt podróży} \\geq \\sum_{i=1}^{n} a_ikoszt podroˊz˙y≥∑i=1n​ai​. Zatem możemy od razu dodać taką wartość do wyniku, a koszty bib_ibi​ zmniejszyć o 111, uzyskując odpowiednio {0,1}\\{0, 1\\}{0,1}. Czyli teraz płacimy tylko w miastach o pierwotnych koszcie 222, a w pozostałych paliwo dostajemy “za darmo”.\nKiedy coś jest darmowe, oczywistym jest, że chcemy to brać, ba, weźmiemy ile się tylko da. Ta mądrość życiowa przejawia się też w zadaniu, więc w miastach typu 000 będziemy brać maksymalnie dużo paliwa. W miastach typu 111 weźmiemy zupełne minimum - tylko tyle, aby dojechać do następnego. (Nie chcemy przecież sytuacji, gdzie zostało nam jakieś paliwo, za które musieliśmy zapłacić, gdy w nowym mieście możemy je mieć za darmo.)\nStąd intuicja, żeby dla każdego miasta wyznaczyć ostatnie miasto typu 000, które pojawia się przed nim. W nim kupimy dokładnie tyle, minimum z tego, ile będziemy potrzebować na dalszą podróż i kkk (wliczyliśmy to do wyniku na samym początku). Teraz “łańcuch” ((miasto typu 000, xxx ⋅\\cdot⋅ miasto typu 111)) miast typu 111 będzie zużywał to paliwo, w pewnym momencie się ono wyczerpie (lub będzie go niewystarczająco) i dokonamy normalnego zakupu.\nWszystko możemy zrobić dla pojedynczego lll w O(n)\\mathcal{O}(n)O(n), powtarzamy nnn razy, stąd O(n2)\\mathcal{O}(n^2)O(n2).","limity#Limity":"W liczbach całkowitych:\n1≤t≤1041 \\leq t \\leq 10^{4}1≤t≤104 (liczba przypadków do rozpatrzenia) 3≤n≤2⋅1053 \\leq n \\leq 2 \\cdot 10^{5}3≤n≤2⋅105 (liczba miast) 1≤k≤1091 \\leq k \\leq 10^{9}1≤k≤109 (maksymalna pojemność zbiornika) 1≤ai≤k1 \\leq a_i \\leq k1≤ai​≤k (odległość do następnego miasta) 1≤bi≤21 \\leq b_i \\leq 21≤bi​≤2 (koszt zakupu paliwa w mieście) ∑n≤2⋅105\\sum n \\leq 2 \\cdot 10^{5}∑n≤2⋅105","rozwiązanie#Rozwiązanie":"Pierwszym typowym w takich zadaniach pomysłem jest “rozwinięcie” okrągu w prostą. Wtedy każdy indeks będzie miał dwie kopie. Dokładniej: iii oraz i+ni+ni+n odpowiadają temu samemu miastu. Wtedy dla dowolnego początku lll, przedział [l,l+n−1][l, l+n-1][l,l+n−1] będzie podróżą po okręgu.","treść#Treść":"NNN miast (oznaczonych 1,2,…,n{1, 2, \\dots, n}1,2,…,n) znajduje się na pewnym okręgu w tej kolejności. Z miasta iii możemy przedostać się do (i+1)(i+1)(i+1)-wszego (gdzie dla nnn jako kolejne przyjmujemy miasto 111).\nNiech f(i)f(i)f(i) oznacza minimalny koszt podróży wokół okręgu, jeśli zaczynamy w mieście iii. Dla każdego iii chcemy znaleźć wartość f(i)f(i)f(i).\nPoruszanie się wymaga paliwa, a nasz pojazd ma kkk-litrowy zbiornik (więcej nie zmieścimy w danej jednostce czasu). W mieście iii koszt 1l1 l1l paliwa wynosi bib_ibi​ (zauważ, że bib_ibi​ przyjmuje bardzo specyficzne wartości). Wiemy też, że odległość z miasta iii do kolejnego wynosi aia_iai​.","wzorcówka#Wzorcówka":"Zamiast brutalnie symulować proces dla każdego miasta, zauważmy, że duży fragment podróży jest wspólny dla początków w iii oraz w i+1i+1i+1.\nZatem spróbujmy wykorzystać brutalne policzenie wyniku dla l=1l=1l=1 i “indukcyjnie” zamieniać go w wynik dla l=2,3,…,nl=2, 3, \\dots, nl=2,3,…,n w czasie O(szybko)\\mathcal{O}(\\textit{szybko})O(szybko).\nIntuicyjne jest utrzymywanie przedziału [l,r][l, r][l,r] i przesuwanie obu końców o 111 w prawo. Takie przesunięcie może utworzyć nowy łańcuch lub przeciąć stary.\nOgólnie, miasto iii ma dwa różne możliwe koszty: c0,ic_{0, i}c0,i​ (z wpływem poprzedzającego iii miasta typu 000) oraz c1,ic_{1, i}c1,i​ (bez tego wpływu).\nZauważmy, że dodanie miasta na koniec (przedłużanie istniejącego łańcucha lub tworzenie nowego) są proste. Pozostaje rozwiązać problem aktualizowania łańcucha, który przecinamy poprzez przesunięcie lll.\nAle i to jest proste i szybkie, ponieważ sumarycznie miast w łańcuchach jest O(n)\\mathcal{O}(n)O(n). Możemy robić “two-pointers”, gdzie zamieniamy wyniki miast z c0,ic_{0, i}c0,i​ na c1,ic_{1, i}c1,i​ na początku przedziału.\nZatem końcowa złożoność to amortyzowane O(n)\\mathcal{O}(n)O(n).\nmoje rozwiązanie: https://codeforces.com/contest/1809/submission/356549648"},"title":"Codeforces 1809F"},"/blog/smol-preoi-d1w/":{"data":{"":"Note\nW trosce o zachowanie rozwiązań zadań w tajemnicy dla przyszłych edycji konkursu, nie będą podawane ich pełne nazwy. Zamiast nich będą stosowane oznaczenia z numerem dnia oraz pierwszą literą nazwy zadania. W ten sposób uczestnicy konkursu, z którego pochodzi zadanie odnajdą omówienie, gdy pozostałe osoby nie go rozpoznają.","rozwiązanie#Rozwiązanie":"Na bazie ciągu a(n) a(n) a(n) konstruujemy ciąg b(n−1) b(n-1) b(n−1). Niech b[i]=(a[i]≤a[i+1]) b[i]=(a[i] \\leq a[i+1]) b[i]=(a[i]≤a[i+1]). Wtedy postępujemy podobnie do rozwiązania przedstawionego na omówieniu po konteście - budujemy drzewo przedziałowe, na którym robimy dp dp dp, w którym łączymy ciągi 11…111 \\dots 111…1.\nTODO: opowiedz o metodzie dp na drzewie przedziałowym","treść#Treść":"Dany jest N N N-elementowy ciąg a(n) a(n) a(n). Potrzebujemy obsłużyć Q Q Q zapytań (typu 1 1 1) o ilość spójnych podciągów niemalejących na przedziale a[L,R] a[L, R] a[L,R]. Są też zapytania (typ 2 2 2) o zmianę wartości a[i] a[i] a[i] na x x x.","założenia#Założenia":"1≤N≤2⋅105 1 \\leq N \\leq 2 \\cdot 10^5 1≤N≤2⋅105 1≤Q≤2⋅105 1 \\leq Q \\leq 2 \\cdot 10^5 1≤Q≤2⋅105 1≤a[i],x≤109 1 \\leq a[i], x \\leq 10^9 1≤a[i],x≤109"},"title":"Smol PREOI 2025 D1W"}}